"""
This is the main program of the L-band project. 
"""

import numpy as np
import pyhdust.phc as phc
import pyhdust.spectools as spt
import pyhdust.lrr as lrr
import matplotlib.pyplot as plt
import emcee
import glob as glob
import read_data as read_data
import read_everything as read_everything


#############################
### This is the zeroth part of the analysis: reading everything (or almost!).
### We will read the observables calculated from the SED's (which were calculated 
### in another program, because this task takes time) and we will
### also read the available observational data on the Be stars.
### With this data, it is possible to make the analysis intended by this 
### program.

#############################
### Full name of the file containing the observables generated from 
### HDUST's output. 
### (This file was generated by 'observables_OldBeAtlas.py'.)
fileobservables = "observables_BeAtlas.txt" 

### Reading that file.
g0 = open(fileobservables,'r')
g0linhas = g0.readlines()
g0.close()
### Splitting the contents of each line (to be used below).
for ilinha in range(0,len(g0linhas)):
    g0linhas[ilinha] = g0linhas[ilinha].split()

### Declaring the lists that will receive the different observables. 
### This is a preliminary step, before making the arrays for each observable.

### The lists of observables of four model parameters
TEMP_read = []
SOURCE_read = []

### The lists of observables of the four model parameters + cosi
SNRATIOS_read = []
###    
UBVRI_read = []
JHK_read = []
HALPHA_SOAR_read = []
WISE_filters_read = []
ALPHA_WISE_read = []
IRAC_filters_read = []
### 
LINE_HALPHA_read = []
LINE_HBETA_read = []
LINE_HGAMMA_read = []    
###
LINE_BRALPHA_read = []   
LINE_BRGAMMA_read = []    
### 
LINE_PFGAMMA_read = []    
###
LINE_HUMPHREY14_read = []
LINE_HUMPHREY15_read = []
LINE_HUMPHREY16_read = []
LINE_HUMPHREY18_read = []
LINE_HUMPHREY19_read = []
LINE_HUMPHREY20_read = []
LINE_HUMPHREY21_read = []
LINE_HUMPHREY22_read = []
LINE_HUMPHREY23_read = []
LINE_HUMPHREY24_read = []
LINE_HUMPHREY25_read = []
###
BL_FLUX_read = []    
RL_FLUX_read = []    


### Filling the lists with the data from the file

MODEL_key = 0 ### will be equal to 1 when in the subfolder of some model.
COSI_key = 0  ### will be equal to 1 when in the subfolder of some cosi.
for ilinha in range(0,len(g0linhas)):
    ### Check if entering a new model. If yes, read the model's parameters.
    if g0linhas[ilinha][0] == "MODEL" and MODEL_key == 0:
        current_MODEL = [g0linhas[ilinha][ii] for ii in range(1,5)]
        MODEL_key = 1
    ### Check if entering a SOURCE line. If yes, read the source parameters.
    if g0linhas[ilinha][0] == "SOURCE" and MODEL_key == 1:
        ### 'SOURCE_read' will receive a new element composed of 2 lists:
        ### 0: model parameters (not including cosi)
        ### 1: elements of 'SOURCE_read'
        current_SOURCE = [g0linhas[ilinha][ii] for ii in range(1,6)]
        SOURCE_read.append([current_MODEL,current_SOURCE])
    ### Check if entering the two TEMP_R and TEMP_T lines.
    ### If yes, read these parameters.
    if g0linhas[ilinha][0] == "TEMP_R" and MODEL_key == 1:
        ### 'TEMP_read' will receive a new element composed of 3 lists:
        ### 0: model parameters (not including cosi)
        ### 1: radial distances in the plane of the disk (R/Req)
        ### 2: temperatures of the disk [K]
        current_TEMP_R = [g0linhas[ilinha][ii] \
            for ii in range(1,len(g0linhas[ilinha]))]
        current_TEMP_T = [g0linhas[ilinha+1][ii] \
            for ii in range(1,len(g0linhas[ilinha+1]))]
        TEMP_read.append([current_MODEL,current_TEMP_R,current_TEMP_T])
    ### Check if entering a new cosi. If yes, read the cosi.
    if g0linhas[ilinha][0] == "COSI" and MODEL_key == 1 and COSI_key == 0:
        ### For a certain model, entering a new inclination (cosi)
        current_COSI = g0linhas[ilinha][1]
        COSI_key = 1
        
    
    def reading_procedure(lista,linename,Nelems):
        """
        
        """
        ### Check if entering a new 'linename'. 
        if g0linhas[ilinha][0] == linename and COSI_key == 1:
            ### 'lista' will receive a new element composed of 2 lists:
            ### 0: model parameters (including cosi)
            ### 1: elements of 'lista'
            auxi = [current_MODEL[ii] for ii in range(0,len(current_MODEL))]
            auxi.append(current_COSI)
            auxi2 = [g0linhas[ilinha][ii] for ii in range(1,Nelems)]
            lista.append([auxi,auxi2])
        return 

    reading_procedure(SNRATIOS_read,"SNRATIOS",len(g0linhas[ilinha]))
    ###
    reading_procedure(UBVRI_read,"UBVRI",1+5)
    reading_procedure(JHK_read,"JHK",1+3)
    reading_procedure(HALPHA_SOAR_read,"HALPHA_SOAR",1+1)
    reading_procedure(WISE_filters_read,"WISE_filters",1+4)
    reading_procedure(ALPHA_WISE_read,"ALPHA_WISE",1+3)
    reading_procedure(IRAC_filters_read,"IRAC_filters",1+4)
    ###
    reading_procedure(LINE_HALPHA_read,"LINE_HALPHA",1+5)
    reading_procedure(LINE_HBETA_read,"LINE_HBETA",1+5)
    reading_procedure(LINE_HGAMMA_read,"LINE_HGAMMA",1+5)    
    ###
    reading_procedure(LINE_BRALPHA_read,"LINE_BRALPHA",1+5)
    reading_procedure(LINE_BRGAMMA_read,"LINE_BRGAMMA",1+5)    
    ###
    reading_procedure(LINE_PFGAMMA_read,"LINE_PFGAMMA",1+5)    
    ###
    reading_procedure(LINE_HUMPHREY14_read,"LINE_HUMPHREY14",1+5)
    reading_procedure(LINE_HUMPHREY15_read,"LINE_HUMPHREY15",1+5)
    reading_procedure(LINE_HUMPHREY16_read,"LINE_HUMPHREY16",1+5)
    reading_procedure(LINE_HUMPHREY18_read,"LINE_HUMPHREY18",1+5)
    reading_procedure(LINE_HUMPHREY19_read,"LINE_HUMPHREY19",1+5)
    reading_procedure(LINE_HUMPHREY20_read,"LINE_HUMPHREY20",1+5)
    reading_procedure(LINE_HUMPHREY21_read,"LINE_HUMPHREY21",1+5)
    reading_procedure(LINE_HUMPHREY22_read,"LINE_HUMPHREY22",1+5)
    reading_procedure(LINE_HUMPHREY23_read,"LINE_HUMPHREY23",1+5)
    reading_procedure(LINE_HUMPHREY24_read,"LINE_HUMPHREY24",1+5)
    reading_procedure(LINE_HUMPHREY25_read,"LINE_HUMPHREY25",1+5)
    ###
    reading_procedure(BL_FLUX_read,"BL_FLUX",1+3)    
    reading_procedure(RL_FLUX_read,"RL_FLUX",1+3)    

    ### Check if finishing the cosi subfolder
    if g0linhas[ilinha][0] == "END_COSI" and COSI_key == 1:
        COSI_key = 0
    ### Check if finishing the model subfolder
    if g0linhas[ilinha][0] == "END_MODEL" and MODEL_key == 1:
        MODEL_key = 0





### The domain of the grids:
npar, sigpar, Mpar, obpar, cosipar = read_everything.domain_PLgrid()


### Now, creating the arrays for the observables of 4+1 model parameters
### The arrays will be functions of: (i_n, i_Sig, i_M, i_ob, i_cosi, #)

def attribution_procedure5(lista_read,Nelems):
    """
    This function creates the 6-array associated with the 'lista_read' 
    given. (5 of these dimensions are the 5 dimensions of the BeAtlas grid.)
    """
    
    array = np.zeros((len(npar),len(sigpar),len(Mpar),len(obpar),\
            len(cosipar),Nelems))
    array[:] = np.nan

    if len(lista_read) > 0:

        for i in range(0,len(lista_read)):
            idxnpar = npar.index(lista_read[i][0][0])
            idxsigpar = sigpar.index(lista_read[i][0][1])
            idxMpar = Mpar.index(lista_read[i][0][2])
            idxobpar = obpar.index(lista_read[i][0][3])
            idxcosipar = cosipar.index(lista_read[i][0][4])

            for j in range(0,Nelems):
                array[idxnpar,idxsigpar,idxMpar,idxobpar,idxcosipar,j] = \
                    float(lista_read[i][1][j])
                    
    return array
    
    
    

if len(SNRATIOS_read) > 0:
    SNRATIOS = attribution_procedure5(SNRATIOS_read,len(SNRATIOS_read[0][1]))
else:
    SNRATIOS = attribution_procedure5(SNRATIOS_read,0)

UBVRI = attribution_procedure5(UBVRI_read,5)
JHK = attribution_procedure5(JHK_read,3)
HALPHA_SOAR = attribution_procedure5(HALPHA_SOAR_read,1)
WISE = attribution_procedure5(WISE_filters_read,4)
ALPHA_WISE = attribution_procedure5(ALPHA_WISE_read,3)
IRAC = attribution_procedure5(IRAC_filters_read,4)
###
LINE_HALPHA = attribution_procedure5(LINE_HALPHA_read,5)
LINE_HBETA = attribution_procedure5(LINE_HBETA_read,5)
LINE_HGAMMA = attribution_procedure5(LINE_HGAMMA_read,5)
###
LINE_BRGAMMA = attribution_procedure5(LINE_BRGAMMA_read,5)
###
LINE_BRALPHA = attribution_procedure5(LINE_BRALPHA_read,5)
###
LINE_PFGAMMA = attribution_procedure5(LINE_PFGAMMA_read,5)
###
LINE_HUMPHREY14 = attribution_procedure5(LINE_HUMPHREY14_read,5)
LINE_HUMPHREY15 = attribution_procedure5(LINE_HUMPHREY15_read,5)
LINE_HUMPHREY16 = attribution_procedure5(LINE_HUMPHREY16_read,5)
LINE_HUMPHREY18 = attribution_procedure5(LINE_HUMPHREY18_read,5)
LINE_HUMPHREY19 = attribution_procedure5(LINE_HUMPHREY19_read,5)
LINE_HUMPHREY20 = attribution_procedure5(LINE_HUMPHREY20_read,5)
LINE_HUMPHREY21 = attribution_procedure5(LINE_HUMPHREY21_read,5)
LINE_HUMPHREY22 = attribution_procedure5(LINE_HUMPHREY22_read,5)
LINE_HUMPHREY23 = attribution_procedure5(LINE_HUMPHREY23_read,5)
LINE_HUMPHREY24 = attribution_procedure5(LINE_HUMPHREY24_read,5)
LINE_HUMPHREY25 = attribution_procedure5(LINE_HUMPHREY25_read,5)
###
BL_FLUX = attribution_procedure5(BL_FLUX_read,3)
RL_FLUX = attribution_procedure5(RL_FLUX_read,3)



### TODO: attribution procedure for the TEMP_T 
### (assuming that all TEMP_R are equal)
### DONE!
    

def attribution_procedure4(lista_read,Nelems):
    """
    This function creates the 5-array associated with the 'lista_read' 
    given. (4 of these dimensions are the 5-1 
    dimensions of the BeAtlas grid, minus cosi.)
    """
    
    array = np.zeros((len(npar),len(sigpar),len(Mpar),len(obpar),Nelems))
    array[:] = np.nan

    if len(lista_read) > 0:

        for i in range(0,len(lista_read)):
            idxnpar = npar.index(lista_read[i][0][0])
            idxsigpar = sigpar.index(lista_read[i][0][1])
            idxMpar = Mpar.index(lista_read[i][0][2])
            idxobpar = obpar.index(lista_read[i][0][3])

            for j in range(0,Nelems):
                array[idxnpar,idxsigpar,idxMpar,idxobpar,j] = np.nan
            for j in range(0,len(lista_read[i][1])):
                array[idxnpar,idxsigpar,idxMpar,idxobpar,j] = \
                    float(lista_read[i][1][j])
                    
    return array


### 
SOURCE = attribution_procedure4(SOURCE_read,5)



### TEMP_read.append([current_MODEL,current_TEMP_R,current_TEMP_T])

TEMP_R_read = [[elem[0],elem[1]] for elem in TEMP_read]
TEMP_T_read = [[elem[0],elem[2]] for elem in TEMP_read]

elemm = [np.nan, np.nan]
ielemm = 0
while np.isnan(float(elemm[0])) and np.isnan(float(elemm[1])) \
        and ielemm < len(TEMP_R_read):
    elemm = TEMP_R_read[ielemm][1]
    ielemm += 1
    
TEMP_R = np.array([float(x) for x in elemm])


Nelems = len(TEMP_R)
TEMP_T = attribution_procedure4(TEMP_T_read,Nelems)






#import sys; sys.exit()


#############################
### Central wavelength of each line [microns]
LINE_HALPHA_lbd = spt.hydrogenlinewl(3, 2)*1e6
LINE_HBETA_lbd = spt.hydrogenlinewl(4, 2)*1e6
LINE_HGAMMA_lbd = spt.hydrogenlinewl(5, 2)*1e6
LINE_BRGAMMA_lbd = spt.hydrogenlinewl(7, 4)*1e6
LINE_BRALPHA_lbd = spt.hydrogenlinewl(5, 4)*1e6
LINE_PFGAMMA_lbd = spt.hydrogenlinewl(8, 5)*1e6
LINE_HUMPHREY14_lbd = spt.hydrogenlinewl(14, 6)*1e6
LINE_HUMPHREY15_lbd = spt.hydrogenlinewl(15, 6)*1e6
LINE_HUMPHREY16_lbd = spt.hydrogenlinewl(16, 6)*1e6
LINE_HUMPHREY18_lbd = spt.hydrogenlinewl(18, 6)*1e6
LINE_HUMPHREY19_lbd = spt.hydrogenlinewl(19, 6)*1e6
LINE_HUMPHREY20_lbd = spt.hydrogenlinewl(20, 6)*1e6
LINE_HUMPHREY21_lbd = spt.hydrogenlinewl(21, 6)*1e6
LINE_HUMPHREY22_lbd = spt.hydrogenlinewl(22, 6)*1e6
LINE_HUMPHREY23_lbd = spt.hydrogenlinewl(23, 6)*1e6
LINE_HUMPHREY24_lbd = spt.hydrogenlinewl(24, 6)*1e6
LINE_HUMPHREY25_lbd = spt.hydrogenlinewl(25, 6)*1e6




##########################################################
### The list DATA_LBAND will contain important parameters derived from the 
### observables of our stars. Check the program 'read_data.py' to know the 
### contents of DATA_LBAND.
DATA_LBAND = read_data.returnDATA_LBAND()

fluxhumphreys, EWhumphreys, GFWHMhumphreys, \
fluxBra, EWBra, GFWHMBra, \
fluxPfg, EWPfg, GFWHMPfg = read_data.LBAND_lines_extract(DATA_LBAND)


### If you want to make the tables of data for the paper, turn this on:
if 1==2:
    lixo = read_data.make_table_obs1(DATA_LBAND,"./tables/table_obs1.txt")
    lixo = read_data.make_table_obs2(DATA_LBAND,"./tables/table_obs2.txt")
    lixo = read_data.make_bigtables_obs(DATA_LBAND,"./tables/bigtables_obs.txt")





##########################################################
### TODO Fredy's task: Generate prior distribution and save in external file.
### I will use it to plot qs in the observed diagrams.



##########################################################
##########################################################
### Now, comes the PART-1 of the analysis: making lots of plots!
### Some of these plots will be on the paper.

### Directory for the figures:
figures = "Figures/"


if 1==2:

    names = []
    alphaL = []
    erralphaL = []
    BL = []
    errBL = []
    MW3 = []
    errMW3 = []
    alphaW1W2 = []
    erralphaW1W2 = []
    alphaW2W3 = []
    erralphaW2W3 = []
    alphaW3W4 = []
    erralphaW3W4 = []

    for ifile in range(0,len(DATA_LBAND)):
        names.append(DATA_LBAND[ifile][0])
    
        alphaL.append(DATA_LBAND[ifile][5][4][0])
        erralphaL.append(DATA_LBAND[ifile][5][4][1]) 
        BL.append(DATA_LBAND[ifile][5][3][0])
        errBL.append(DATA_LBAND[ifile][5][3][1])

        MW3.append(DATA_LBAND[ifile][6][5][4])
        errMW3.append(DATA_LBAND[ifile][6][5][5])
        alphaW1W2.append(DATA_LBAND[ifile][6][2][0])
        erralphaW1W2.append(DATA_LBAND[ifile][6][2][1])
        alphaW2W3.append(DATA_LBAND[ifile][6][3][0])
        erralphaW2W3.append(DATA_LBAND[ifile][6][3][1])
        alphaW3W4.append(DATA_LBAND[ifile][6][4][0])
        erralphaW3W4.append(DATA_LBAND[ifile][6][4][1])


    plt.figure(figsize=(11,11))
    plt.subplot(221)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaL[i],BL[i],xerr=erralphaL[i],yerr=errMW3[i],color="red",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaL[i],BL[i]])
        plt.xlabel("$\\alpha_L$")
        plt.ylabel("$M_{B_L}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.subplot(222)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaW1W2[i],MW3[i],xerr=erralphaW1W2[i],yerr=errMW3[i],color="green",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaW1W2[i],MW3[i]])
        plt.xlabel("$\\alpha_{W1-W2}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.subplot(223)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaW2W3[i],MW3[i],xerr=erralphaW2W3[i],yerr=errMW3[i],color="blue",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaW2W3[i],MW3[i]])
        plt.xlabel("$\\alpha_{W2-W3}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.subplot(224)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaW3W4[i],MW3[i],xerr=erralphaW3W4[i],yerr=errMW3[i],color="purple",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaW3W4[i],MW3[i]])
        plt.xlabel("$\\alpha_{W3-W4}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.tight_layout()
    plt.show()





#############################
### TODO: plots of the SEDs and line profiles
if 1==2:

    import read_everything
    
    ### Reading fullsed, source and temperature files
    files_fullsed_new, files_source_new, files_temps_new, fullsed_contents, \
            fullsed_path, source_path, temps_path, dist_std = \
            read_everything.read_everything()




#############################
### Plotting observed Lenorzer Diagrams
if 1==2:

    ### Parameters for the double arcsinh scaling:
    up1 = 1.
    up2 = 5.  ### since most of the measured flux ratios are between 
                ### 0.1 and 1, the choice of up2 = 100 garantees the 
                ### nearly logarithmic behaviour of the scale for them.
    down1 = 0.2 * up1   ### This makes a "compression" of the negative axis.
    down2 = 5.

    names = []
    XL = []
    errXL = []
    YL = []
    errYL = []
    H14BL = []
    errH14BL = []
    for ifile in range(0,len(DATA_LBAND)):
        names.append(DATA_LBAND[ifile][0])
        XL.append(fluxhumphreys[ifile,14,0]/fluxPfg[ifile,0])
        YL.append(fluxhumphreys[ifile,14,0]/fluxBra[ifile,0])
        H14BL.append(fluxhumphreys[ifile,14,0]/DATA_LBAND[ifile][5][0][0]*\
                (DATA_LBAND[ifile][5][0][3]-DATA_LBAND[ifile][5][0][2]))
        
        errXL.append(abs(XL[-1])*np.sqrt(
                fluxhumphreys[ifile,14,1]**2./fluxhumphreys[ifile,14,0]**2.+\
                fluxPfg[ifile,1]**2./fluxPfg[ifile,0]**2.\
                ))
        errYL.append(abs(YL[-1])*np.sqrt(
                fluxhumphreys[ifile,14,1]**2./fluxhumphreys[ifile,14,0]**2.+\
                fluxBra[ifile,1]**2./fluxBra[ifile,0]**2.\
                ))
        errH14BL.append(abs(H14BL[-1])*np.sqrt(
                fluxhumphreys[ifile,14,1]**2./fluxhumphreys[ifile,14,0]**2.+\
                DATA_LBAND[ifile][5][0][1]**2./DATA_LBAND[ifile][5][0][0]**2.\
                ))
    

            
    ### Defining the labels of the axis
    axisvalsy=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.02,0.01,0.,\
                            -0.05,-0.5,-5.,-50.,500.])
    axisvalsx=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.01,0.,\
                            -0.5,-50.,500.])
    ### Obtaing the positions of the above defined labels of the axis
    transf_axisvalsy=np.array([lrr.scale_two_arcsinh(axisvalsy[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsy))])
    transf_axisvalsx=np.array([lrr.scale_two_arcsinh(axisvalsx[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsx))])

    ### Converting to the double arcsinh scale, for plotting:
    XLplot=np.array([lrr.scale_two_arcsinh(XL[i],up1,up2,down1,down2) \
        for i in range(0,len(XL))])
    YLplot=np.array([lrr.scale_two_arcsinh(YL[i],up1,up2,down1,down2) \
        for i in range(0,len(YL))])
    errXLplot=np.array([abs(lrr.scale_two_arcsinh(XL[i],up1,up2,down1,down2,\
        m="deriv"))*errXL[i] for i in range(0,len(errXL))])
    errYLplot=np.array([abs(lrr.scale_two_arcsinh(YL[i],up1,up2,down1,down2,\
        m="deriv"))*errYL[i] for i in range(0,len(errYL))])

    if 1==1:
        
        plt.figure(1,figsize=(11,11), dpi=100)

        plt.plot([0.,0.],[-1e32,1e32],linestyle=":",color="black",\
            linewidth=0.6)  ### Vertical dotted line
        plt.plot([-1e32,1e32],[0.,0.],linestyle=":",color="black",\
            linewidth=0.6)  ### Horizontal dotted line
    
        type1_x = -0.1
        type1_y = -0.2
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2)],\
                    [lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),1e32],linestyle=":",color="blue",\
            linewidth=0.5)  ### Vertical line delimiting "type 1 region"
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),1e32],[lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2)],linestyle=":",color="blue",\
            linewidth=0.5)  ### Horizontal line delimiting "type 1 region"
    
    
        for i in xrange(0,len(XLplot)):
            if H14BL[i] >= 0.:
                markk="o"
            else:
                markk="^"
            #if ~np.isnan(XL[i]) and ~np.isnan(YL[i]):
            plt.scatter([XLplot[i]],[YLplot[i]],marker=markk,\
                    s=1e4*(np.abs(H14BL[i])+np.abs(errH14BL[i]))/0.06e4,\
                    color="blue",facecolors="None")
            plt.scatter([XLplot[i]],[YLplot[i]],marker=markk,\
                    s=1e4*(np.abs(H14BL[i])-np.abs(errH14BL[i]))/0.06e4,\
                    color="red",facecolors="None")
            plt.errorbar([XLplot[i]],[YLplot[i]],xerr=errXLplot[i],\
                    yerr=errYLplot[i],color="black")
            plt.annotate("HD "+names[i],[XLplot[i],YLplot[i]])
            
    
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.01$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.003$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.001$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.001$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.01$")
        ### Add a legend
        plt.legend()

        plt.xscale('linear')
        plt.yscale('linear')
        plt.xlabel("$F(\mathrm{H}_{14})/F(\mathrm{Pf}_{\gamma})$")
        plt.ylabel("$F(\mathrm{H}_{14})/F(\mathrm{Br}_{\\alpha})$")
        plt.xticks(transf_axisvalsx,axisvalsx)
        plt.yticks(transf_axisvalsy,axisvalsy)
        plt.xlim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        plt.ylim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        
        plt.tight_layout()
        plt.savefig(figures+"LENORZERDATA.png")





#############################
### Plotting theoretical Lenorzer Diagrams
if 1==2:

    ### Parameters for the double arcsinh scaling:
    up1 = 1.
    up2 = 5.  ### since most of the measured flux ratios are between 
                ### 0.1 and 1, the choice of up2 = 100 garantees the 
                ### nearly logarithmic behaviour of the scale for them.
    down1 = 0.2 * up1   ### This makes a "compression" of the negative axis.
    down2 = 5.

    
    XL=[]
    YL=[]
    H14BL=[]
    figname=[]
    figtitle=[]
    annotate_vec=[]
    i_n = npar.index("4.5")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("04.20")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")
    
    ###
    #kinit = 1
    #colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    #for iplot1 in range(0,len(sigpar)):
    #    auxi_XL=[]
    #    auxi_YL=[]
    #    auxi_H14BL=[]
    #    auxi_annotate_vec=[]
    #    for iplot2 in range(0,len(cosipar)):
    #        auxi_XL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
    #            LINE_PFGAMMA[i_n,iplot1,i_M,i_ob,iplot2,0])
    #        auxi_YL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
    #            LINE_BRALPHA[i_n,iplot1,i_M,i_ob,iplot2,0])
    #        auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
    #            BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*\
    #                   (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
    #                   BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1])*1e4)
    #        auxi_annotate_vec.append("$\cos i$ = "+\
    #                str(round(abs(float(cosipar[iplot2])),2)))
    #    XL.append(auxi_XL)
    #    YL.append(auxi_YL)
    #    H14BL.append(auxi_H14BL)
    #    annotate_vec.append(auxi_annotate_vec)
    #    figname.append("n{0}_sig{1}_M{2}_ob{3}_cosi_X.png".format(\
    #        npar[i_n],sigpar[iplot1],Mpar[i_M],obpar[i_ob]))
    #    figtitle.append("$n="+npar[i_n]+"$, $\Sigma_0="+sigpar[iplot1]+\
    #        "\,\mathrm{g\,cm^{-2}}$")

    ###
    kinit = 0
    colorvec=["black","black","black","black","black","black","black",\
                    "black","black","black"]
    for iplot2 in range(0,len(cosipar)):
        auxi_XL=[]
        auxi_YL=[]
        auxi_H14BL=[]
        auxi_annotate_vec=[]
        for iplot1 in range(0,len(sigpar)):
            auxi_XL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                LINE_PFGAMMA[i_n,iplot1,i_M,i_ob,iplot2,0])
            auxi_YL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                LINE_BRALPHA[i_n,iplot1,i_M,i_ob,iplot2,0])
            auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*\
                        (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                        BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1])*1e4)
            auxi_annotate_vec.append("$\Sigma_0$ = "+sigpar[iplot1])
        XL.append(auxi_XL)
        YL.append(auxi_YL)
        H14BL.append(auxi_H14BL)
        annotate_vec.append(auxi_annotate_vec)
        figname.append("n{0}_sigX.XX_M{1}_ob{2}_cosi_{3}.png".format(\
            npar[i_n],Mpar[i_M],obpar[i_ob],str(round(abs(float(cosipar[iplot2])),2)) ))
        figtitle.append("$n="+npar[i_n]+"$, $\cos i = "+\
                    str(round(abs(float(cosipar[iplot2])),2))+"$")


    ### 
    XL=[np.array(XL[k]) for k in range(0,len(XL))]
    YL=[np.array(YL[k]) for k in range(0,len(XL))]
    H14BL=[np.array(H14BL[k]) for k in range(0,len(XL))]
        
    ### Defining the labels of the axis
    axisvalsy=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.02,0.01,0.,\
                            -0.05,-0.5,-5.,-50.,500.])
    axisvalsx=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.01,0.,\
                            -0.5,-50.,500.])
    ### Obtaing the positions of the above defined labels of the axis
    transf_axisvalsy=np.array([lrr.scale_two_arcsinh(axisvalsy[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsy))])
    transf_axisvalsx=np.array([lrr.scale_two_arcsinh(axisvalsx[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsx))])

    ### Converting to the double arcsinh scale, for plotting:
    XLplot=[np.array([lrr.scale_two_arcsinh(XL[k][i],up1,up2,down1,down2) \
        for i in range(0,len(XL[k]))]) for k in range(0,len(XL))]
    YLplot=[np.array([lrr.scale_two_arcsinh(YL[k][i],up1,up2,down1,down2) \
        for i in range(0,len(YL[k]))]) for k in range(0,len(YL))]


    for k in range(kinit,len(XL)):
        
        plt.figure(k,figsize=(5.5, 5.5), dpi=100)

        plt.plot([0.,0.],[-1e32,1e32],linestyle=":",color="black",\
            linewidth=0.6)  ### Vertical dotted line
        plt.plot([-1e32,1e32],[0.,0.],linestyle=":",color="black",\
            linewidth=0.6)  ### Horizontal dotted line
    
        type1_x = -0.1
        type1_y = -0.2
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2)],\
                    [lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),1e32],linestyle=":",color="blue",\
            linewidth=0.5)  ### Vertical line delimiting "type 1 region"
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),1e32],[lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2)],linestyle=":",color="blue",\
            linewidth=0.5)  ### Horizontal line delimiting "type 1 region"
    
    
        plt.plot(XLplot[k],YLplot[k],linewidth=0.3,color=colorvec[k])
        for i in xrange(0,len(XLplot[k])):
            if H14BL[k][i] >= 0.:
                markk="o"
            else:
                markk="^"
            plt.scatter([XLplot[k][i]],[YLplot[k][i]],marker=markk,\
                s=1e4*np.abs(H14BL[k][i])/0.06e4,\
                color=colorvec[k],facecolors="None")
                #alpha=0.5+0.5*float(i)/float(len(XLplot[k])-1))
                #color="black",facecolors="none")
        
        i_init = -1; key_i_init = 0
        i_final = len(XLplot[k]); key_i_final = 0
        while i_init < len(XLplot[k])-1 and key_i_init == 0:
            i_init += 1
            if (XLplot[k][i_init] is not None) and \
                        (YLplot[k][i_init] is not None):
                if (~np.isnan(XLplot[k][i_init])) and \
                        (~np.isnan(YLplot[k][i_init])):
                    key_i_init = 1
        while i_final > 0 and key_i_final == 0:
            i_final -= 1
            if (XLplot[k][i_final] is not None) and \
                        (YLplot[k][i_final] is not None):
                if (~np.isnan(XLplot[k][i_final])) and \
                        (~np.isnan(YLplot[k][i_final])):
                    key_i_final = 1
        
        if (XLplot[k][i_init] is not None) and \
                    (YLplot[k][i_init] is not None):
            if (~np.isnan(XLplot[k][i_init])) and \
                    (~np.isnan(YLplot[k][i_init])):
                plt.text(XLplot[k][i_init],YLplot[k][i_init], \
                        annotate_vec[k][i_init])
        if (XLplot[k][i_final] is not None) and \
                    (YLplot[k][i_final] is not None):
            if (~np.isnan(XLplot[k][i_final])) and \
                    (~np.isnan(YLplot[k][i_final])):
                plt.text(XLplot[k][i_final],YLplot[k][i_final], \
                        annotate_vec[k][i_final])
            
    
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.01$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.003$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.001$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.001$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.01$")
        ### Add a legend
        plt.legend()

        plt.title(figtitle[k])
        plt.xscale('linear')
        plt.yscale('linear')
        plt.xlabel("$F(\mathrm{H}_{14})/F(\mathrm{Pf}_{\gamma})$")
        plt.ylabel("$F(\mathrm{H}_{14})/F(\mathrm{Br}_{\\alpha})$")
        plt.xticks(transf_axisvalsx,axisvalsx)
        plt.yticks(transf_axisvalsy,axisvalsy)
        plt.xlim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        plt.ylim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        
        plt.savefig(figures+"LENORZER_"+figname[k])







#############################
### Plotting Humphrey's diagrams
if 1==2:
    
    ### Parameters for the double arcsinh scaling:
    up1 = 1.
    up2 = 5.    ### since most of the measured flux ratios are between 
                ### 0.1 and 1, the choice of up2 = 100 garantees the 
                ### nearly logarithmic behaviour of the scale for them.
    down1 = 0.2 * up1   ### This makes a "compression" of the negative axis.
    down2 = up2
    
    H14H19=[]; EWL_H14=[]
    H15H19=[]; EWL_H15=[]
    H16H19=[]; EWL_H16=[]
    H18H19=[]; EWL_H18=[]
    H19H19=[]; EWL_H19=[]
    H20H19=[]; EWL_H20=[]
    H21H19=[]; EWL_H21=[]
    H22H19=[]; EWL_H22=[]
    H23H19=[]; EWL_H23=[]
    H24H19=[]; EWL_H24=[]
    H25H19=[]; EWL_H25=[]
    H14BL=[]
    figname=[]
    figtitle=[]
    annotate_vec=[]
    
    i_n = npar.index("4.5")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("04.20")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")


    ### 
    kinit = 1
    colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    for iplot1 in range(0,len(sigpar)):
        auxi_H14H19=[]; auxi_EWL_H14=[]
        auxi_H15H19=[]; auxi_EWL_H15=[]
        auxi_H16H19=[]; auxi_EWL_H16=[]
        auxi_H18H19=[]; auxi_EWL_H18=[]
        auxi_H19H19=[]; auxi_EWL_H19=[]
        auxi_H20H19=[]; auxi_EWL_H20=[]
        auxi_H21H19=[]; auxi_EWL_H21=[]
        auxi_H22H19=[]; auxi_EWL_H22=[]
        auxi_H23H19=[]; auxi_EWL_H23=[]
        auxi_H24H19=[]; auxi_EWL_H24=[]
        auxi_H25H19=[]; auxi_EWL_H25=[]
        auxi_H14BL=[]
        auxi_annotate_vec=[]
        for iplot2 in range(0,len(cosipar)):
            
            def making_fluxratio(auxilist,NUM,DEN):
                auxilist.append(\
                NUM[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                DEN[i_n,iplot1,i_M,i_ob,iplot2,0])
                return
            
            making_fluxratio(auxi_H14H19,LINE_HUMPHREY14,LINE_HUMPHREY19)
            making_fluxratio(auxi_H15H19,LINE_HUMPHREY15,LINE_HUMPHREY19)
            making_fluxratio(auxi_H16H19,LINE_HUMPHREY16,LINE_HUMPHREY19)
            making_fluxratio(auxi_H18H19,LINE_HUMPHREY18,LINE_HUMPHREY19)
            making_fluxratio(auxi_H19H19,LINE_HUMPHREY19,LINE_HUMPHREY19)
            making_fluxratio(auxi_H20H19,LINE_HUMPHREY20,LINE_HUMPHREY19)
            making_fluxratio(auxi_H21H19,LINE_HUMPHREY21,LINE_HUMPHREY19)
            making_fluxratio(auxi_H22H19,LINE_HUMPHREY22,LINE_HUMPHREY19)
            making_fluxratio(auxi_H23H19,LINE_HUMPHREY23,LINE_HUMPHREY19)
            making_fluxratio(auxi_H24H19,LINE_HUMPHREY24,LINE_HUMPHREY19)
            making_fluxratio(auxi_H25H19,LINE_HUMPHREY25,LINE_HUMPHREY19)

            auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                    BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*\
                    (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                    BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1])*1e4)

            def making_ew(auxilist,NUM,DEN):
                auxilist.append(\
                NUM[i_n,iplot1,i_M,i_ob,iplot2,1]/\
                DEN*1e-4)                
                return
            
            making_ew(auxi_EWL_H14,LINE_HUMPHREY14,LINE_HUMPHREY14_lbd)
            making_ew(auxi_EWL_H15,LINE_HUMPHREY15,LINE_HUMPHREY15_lbd)
            making_ew(auxi_EWL_H16,LINE_HUMPHREY16,LINE_HUMPHREY16_lbd)
            making_ew(auxi_EWL_H18,LINE_HUMPHREY18,LINE_HUMPHREY18_lbd)
            making_ew(auxi_EWL_H19,LINE_HUMPHREY19,LINE_HUMPHREY19_lbd)
            making_ew(auxi_EWL_H20,LINE_HUMPHREY20,LINE_HUMPHREY20_lbd)
            making_ew(auxi_EWL_H21,LINE_HUMPHREY21,LINE_HUMPHREY21_lbd)
            making_ew(auxi_EWL_H22,LINE_HUMPHREY22,LINE_HUMPHREY22_lbd)
            making_ew(auxi_EWL_H23,LINE_HUMPHREY23,LINE_HUMPHREY23_lbd)
            making_ew(auxi_EWL_H24,LINE_HUMPHREY24,LINE_HUMPHREY24_lbd)
            making_ew(auxi_EWL_H25,LINE_HUMPHREY25,LINE_HUMPHREY25_lbd)
                        
            auxi_annotate_vec.append("$\cos i$ = "+\
                    str(round(abs(float(cosipar[iplot2])),2)))
                    
        H14H19.append(auxi_H14H19); EWL_H14.append(auxi_EWL_H14)
        H15H19.append(auxi_H15H19); EWL_H15.append(auxi_EWL_H15)
        H16H19.append(auxi_H16H19); EWL_H16.append(auxi_EWL_H16)
        H18H19.append(auxi_H18H19); EWL_H18.append(auxi_EWL_H18)
        H19H19.append(auxi_H19H19); EWL_H19.append(auxi_EWL_H19)
        H20H19.append(auxi_H20H19); EWL_H20.append(auxi_EWL_H20)
        H21H19.append(auxi_H21H19); EWL_H21.append(auxi_EWL_H21)
        H22H19.append(auxi_H22H19); EWL_H22.append(auxi_EWL_H22)
        H23H19.append(auxi_H23H19); EWL_H23.append(auxi_EWL_H23)
        H24H19.append(auxi_H24H19); EWL_H24.append(auxi_EWL_H24)
        H25H19.append(auxi_H25H19); EWL_H25.append(auxi_EWL_H25)
        H14BL.append(auxi_H14BL)
        annotate_vec.append(auxi_annotate_vec)
        figname.append("n{0}_sig{1}_M{2}_ob{3}_cosi_X.png".format(\
            npar[i_n],sigpar[iplot1],Mpar[i_M],obpar[i_ob]))
        figtitle.append("$n="+npar[i_n]+"$, $\Sigma_0="+sigpar[iplot1]+\
            "\,\mathrm{g\,cm^{-2}}$")





    ### 
    H14H19=[np.array(H14H19[k]) for k in range(0,len(H14H19))]
    H15H19=[np.array(H15H19[k]) for k in range(0,len(H15H19))]
    H16H19=[np.array(H16H19[k]) for k in range(0,len(H16H19))]
    H18H19=[np.array(H18H19[k]) for k in range(0,len(H18H19))]
    H19H19=[np.array(H19H19[k]) for k in range(0,len(H19H19))]
    H20H19=[np.array(H20H19[k]) for k in range(0,len(H20H19))]
    H21H19=[np.array(H21H19[k]) for k in range(0,len(H21H19))]
    H22H19=[np.array(H22H19[k]) for k in range(0,len(H22H19))]
    H23H19=[np.array(H23H19[k]) for k in range(0,len(H23H19))]
    H24H19=[np.array(H24H19[k]) for k in range(0,len(H24H19))]
    H25H19=[np.array(H25H19[k]) for k in range(0,len(H25H19))]
    H14BL=[np.array(H14BL[k]) for k in range(0,len(H14BL))]
    EWL_H14=[np.array(EWL_H14[k]) for k in range(0,len(EWL_H14))]
    EWL_H15=[np.array(EWL_H15[k]) for k in range(0,len(EWL_H15))]
    EWL_H16=[np.array(EWL_H16[k]) for k in range(0,len(EWL_H16))]
    EWL_H18=[np.array(EWL_H18[k]) for k in range(0,len(EWL_H18))]
    EWL_H19=[np.array(EWL_H19[k]) for k in range(0,len(EWL_H19))]
    EWL_H20=[np.array(EWL_H20[k]) for k in range(0,len(EWL_H20))]
    EWL_H21=[np.array(EWL_H21[k]) for k in range(0,len(EWL_H21))]
    EWL_H22=[np.array(EWL_H22[k]) for k in range(0,len(EWL_H22))]
    EWL_H23=[np.array(EWL_H23[k]) for k in range(0,len(EWL_H23))]
    EWL_H24=[np.array(EWL_H24[k]) for k in range(0,len(EWL_H24))]
    EWL_H25=[np.array(EWL_H25[k]) for k in range(0,len(EWL_H25))]
        
    ### Defining the labels of the axis
    axisvalsy=np.array([10.,5.,3.,2.,1.,0.5,0.2,0.1,0.,\
                            -0.5,-5.])
    ### Obtaing the positions of the above defined labels of the axis
    transf_axisvalsy=np.array([lrr.scale_two_arcsinh(axisvalsy[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsy))])

    for k in range(kinit,len(H14H19)):

        Dlamb = 0.03
        
        def making_lambdas(lbdcenter,array,Dlamb):
            return np.array([lbdcenter - \
                0.5*Dlamb + Dlamb*float(i)/float(len(array)-1) \
                for i in xrange(0,len(array))])
                
        H14lamb = making_lambdas(LINE_HUMPHREY14_lbd,H14H19[k],Dlamb)
        H15lamb = making_lambdas(LINE_HUMPHREY15_lbd,H15H19[k],Dlamb)
        H16lamb = making_lambdas(LINE_HUMPHREY16_lbd,H16H19[k],Dlamb)
        H18lamb = making_lambdas(LINE_HUMPHREY18_lbd,H18H19[k],Dlamb)
        H19lamb = making_lambdas(LINE_HUMPHREY19_lbd,H19H19[k],Dlamb)
        H20lamb = making_lambdas(LINE_HUMPHREY20_lbd,H20H19[k],Dlamb)
        H21lamb = making_lambdas(LINE_HUMPHREY21_lbd,H21H19[k],Dlamb)
        H22lamb = making_lambdas(LINE_HUMPHREY22_lbd,H22H19[k],Dlamb)
        H23lamb = making_lambdas(LINE_HUMPHREY23_lbd,H23H19[k],Dlamb)
        H24lamb = making_lambdas(LINE_HUMPHREY24_lbd,H24H19[k],Dlamb)
        H25lamb = making_lambdas(LINE_HUMPHREY25_lbd,H25H19[k],Dlamb)
        
        plt.figure(k,figsize=(11, 7), dpi=100)

        plt.subplot(211)
            
        ymax = 15
        horlines = np.array([float(-15+ii) for ii in range(0,2*ymax+2)])
        for elem in horlines:
            plt.plot([-1e32,1e32],
            [lrr.scale_two_arcsinh(elem,up1,up2,down1,down2),\
            lrr.scale_two_arcsinh(elem,up1,up2,down1,down2)],
            linestyle=":",color="black",\
                linewidth=0.6)  ### Horizontal dotted lines
        
        colorvec=["red","green","blue"]
        kcolor=0
        
        def plot_ratio_line(x,y):
            plt.plot(x,np.array([\
                lrr.scale_two_arcsinh(y[j],up1,up2,down1,down2) \
                for j in range(0,len(y))]),\
                linewidth=0.3,color=colorvec[kcolor%3])
            return
        
        plot_ratio_line(H14lamb,H14H19[k]); kcolor+=1
        plot_ratio_line(H15lamb,H15H19[k]); kcolor+=1
        plot_ratio_line(H16lamb,H16H19[k]); kcolor+=1
        plot_ratio_line(H18lamb,H18H19[k]); kcolor+=1
        plot_ratio_line(H19lamb,H19H19[k]); kcolor+=1
        plot_ratio_line(H20lamb,H20H19[k]); kcolor+=1
        plot_ratio_line(H21lamb,H21H19[k]); kcolor+=1
        plot_ratio_line(H22lamb,H22H19[k]); kcolor+=1
        plot_ratio_line(H23lamb,H23H19[k]); kcolor+=1
        plot_ratio_line(H24lamb,H24H19[k]); kcolor+=1
        plot_ratio_line(H25lamb,H25H19[k]); kcolor+=1
        
                
        colorvec=["red","green","blue"]
        kcolor=0
        
        def plot_ratio_scatter(x,y):
            for i in xrange(0,len(y)):
                if H14BL[k][i] >= 0.:
                    markk="o"
                else:
                    markk="^"
                plt.scatter([x[i]],\
                    [lrr.scale_two_arcsinh(y[i],up1,up2,down1,down2)],\
                    marker=markk,\
                    s=1e4*np.abs(H14BL[k][i])/0.06e4,\
                    color=colorvec[kcolor%3],facecolors="None")
            return
            
        plot_ratio_scatter(H14lamb,H14H19[k]); kcolor+=1
        plot_ratio_scatter(H15lamb,H15H19[k]); kcolor+=1
        plot_ratio_scatter(H16lamb,H16H19[k]); kcolor+=1
        plot_ratio_scatter(H18lamb,H18H19[k]); kcolor+=1
        plot_ratio_scatter(H19lamb,H19H19[k]); kcolor+=1
        plot_ratio_scatter(H20lamb,H20H19[k]); kcolor+=1
        plot_ratio_scatter(H21lamb,H21H19[k]); kcolor+=1
        plot_ratio_scatter(H22lamb,H22H19[k]); kcolor+=1
        plot_ratio_scatter(H23lamb,H23H19[k]); kcolor+=1
        plot_ratio_scatter(H24lamb,H24H19[k]); kcolor+=1
        plot_ratio_scatter(H25lamb,H25H19[k]); kcolor+=1
            
            
    
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.01$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.003$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.001$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.001$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.01$")
        ### Add a legend
        #plt.legend()

        plt.subplot(212)

        plt.plot([-1e32,1e32],[0.,0.],linestyle=":",color="black",\
            linewidth=0.6)  ### Horizontal dotted line
            
        colorvec=["red","green","blue"]
        kcolor=0

        def plot_ew_line(x,y):
            plt.plot(x,y*1e4,linewidth=0.3,color=colorvec[kcolor%3])
            return

        plot_ew_line(H14lamb,EWL_H14[k]); kcolor+=1
        plot_ew_line(H15lamb,EWL_H15[k]); kcolor+=1
        plot_ew_line(H16lamb,EWL_H16[k]); kcolor+=1
        plot_ew_line(H18lamb,EWL_H18[k]); kcolor+=1
        plot_ew_line(H19lamb,EWL_H19[k]); kcolor+=1
        plot_ew_line(H20lamb,EWL_H20[k]); kcolor+=1
        plot_ew_line(H21lamb,EWL_H21[k]); kcolor+=1
        plot_ew_line(H22lamb,EWL_H22[k]); kcolor+=1
        plot_ew_line(H23lamb,EWL_H23[k]); kcolor+=1
        plot_ew_line(H24lamb,EWL_H24[k]); kcolor+=1
        plot_ew_line(H25lamb,EWL_H25[k]); kcolor+=1
        
            
        colorvec=["red","green","blue"]
        kcolor=0
        
        def plot_ew_scatter(x,y):
            for i in xrange(0,len(y)):
                if H14BL[k][i] >= 0.:
                    markk="o"
                else:
                    markk="^"
                plt.scatter([x[i]],[y[i]*1e4],marker=markk,\
                    s=1e4*np.abs(H14BL[k][i])/0.06e4,\
                    color=colorvec[kcolor%3],facecolors="None")
            return        
        
        plot_ew_scatter(H14lamb,EWL_H14[k]); kcolor+=1
        plot_ew_scatter(H15lamb,EWL_H15[k]); kcolor+=1
        plot_ew_scatter(H16lamb,EWL_H16[k]); kcolor+=1
        plot_ew_scatter(H18lamb,EWL_H18[k]); kcolor+=1
        plot_ew_scatter(H19lamb,EWL_H19[k]); kcolor+=1
        plot_ew_scatter(H20lamb,EWL_H20[k]); kcolor+=1
        plot_ew_scatter(H21lamb,EWL_H21[k]); kcolor+=1
        plot_ew_scatter(H22lamb,EWL_H22[k]); kcolor+=1
        plot_ew_scatter(H23lamb,EWL_H23[k]); kcolor+=1
        plot_ew_scatter(H24lamb,EWL_H24[k]); kcolor+=1
        plot_ew_scatter(H25lamb,EWL_H25[k]); kcolor+=1
        



        plt.subplot(211)
        plt.title(figtitle[k])
        plt.xscale('linear')
        plt.yscale('linear')
        plt.yticks(transf_axisvalsy,axisvalsy)
        plt.ylabel("$F(\mathrm{H}_{n})/F(\mathrm{H}_{19})$")
        plt.xlabel("$\lambda\,[\mathrm{\mu m}]$")
        plt.xlim([3.4,4.1])
        plt.ylim([lrr.scale_two_arcsinh(-15.,up1,up2,down1,down2),\
            lrr.scale_two_arcsinh(15.,up1,up2,down1,down2)])

        plt.subplot(212)
        plt.xscale('linear')
        plt.yscale('linear')
        plt.ylabel("$EW/\lambda\,[\\times 10^{4}]$")
        plt.xlabel("$\lambda\,[\mathrm{\mu m}]$")
        plt.xlim([3.4,4.1])
        plt.ylim([2.5,-2.5])
        
        plt.savefig(figures+"HUMPHREYS_"+figname[k])




#############################
### Plotting Mennickent-based CMD
if 1==2:

    ###
    lamb1_BL=3.41 ; lamb2_BL=3.47
    lamb1_RL=3.93 ; lamb2_RL=4.00
    Nnpts=50
    xlp,ylp = lrr.VEGA_spct("spct1")
            
    llamb=np.array([lamb1_BL+(lamb2_BL-lamb1_BL)/\
        float(Nnpts-1)*float(i) for i in range(0,Nnpts)])*1e4
    dllamb=np.array([llamb[i+1]-llamb[i] for i in range(0,Nnpts-1)])
    ylpf=np.array([lrr.interpLinND([llamb[i]],[xlp],ylp) \
        for i in range(0,Nnpts)])
    B_Vega=lrr.integrate_trapezia(ylpf,dllamb)
    #print(B_Vega,B_Vega*0.5*(lamb1_BL+lamb2_BL)*1e-4/phc.c.cgs/phc.h.cgs)

    

    XL=[]
    YL=[]
    H14BL=[]
    figname=[]
    figtitle=[]
    annotate_vec=[]
    i_n = npar.index("3.0")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("14.60")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")


    ###
    kinit = 0
    colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    figname_now="n{0}_sigX.XX_M{1}_ob{2}_cosi_X.png".format(\
            npar[i_n],Mpar[i_M],obpar[i_ob])
    for iplot1 in range(0,len(sigpar)):
        auxi_XL=[]
        auxi_YL=[]
        auxi_H14BL=[]
        auxi_annotate_vec=[]
        for iplot2 in range(0,len(cosipar)):
            auxi_XL.append(1.-np.log10(
                (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]/
                (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]))/\
                (RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]/
                (RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]))
                )/np.log10(\
                (RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]+\
                RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2])/\
                (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]+\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2])
                ))
            auxi_YL.append(-2.5*np.log10(
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                B_Vega))
            auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*(lamb2_BL-lamb1_BL)*1e4)
            auxi_annotate_vec.append("$\cos i$ = "+\
                    str(round(abs(float(cosipar[iplot2])),2)))
        XL.append(auxi_XL)
        YL.append(auxi_YL)
        H14BL.append(auxi_H14BL)
        annotate_vec.append(auxi_annotate_vec)
        figname.append("n{0}_sig{1}_M{2}_ob{3}_cosi_X.png".format(\
            npar[i_n],sigpar[iplot1],Mpar[i_M],obpar[i_ob]))
        figtitle.append("$n="+npar[i_n]+"$, $\Sigma_0="+sigpar[iplot1]+\
            "\,\mathrm{g\,cm^{-2}}$")



    ### 
    XL=[np.array(XL[k]) for k in range(0,len(XL))]
    YL=[np.array(YL[k]) for k in range(0,len(XL))]
    H14BL=[np.array(H14BL[k]) for k in range(0,len(XL))]

    plt.figure(0,figsize=(5.5, 5.5), dpi=100)

    for ifile in range(0,len(DATA_LBAND)):
        plt.errorbar([DATA_LBAND[ifile][5][4][0]],[DATA_LBAND[ifile][5][3][0]],\
                    xerr=DATA_LBAND[ifile][5][4][1],\
                    yerr=DATA_LBAND[ifile][5][3][1],color="gray",linewidth=0.3)
    for ifile in range(0,len(DATA_LBAND)):
        plt.text(DATA_LBAND[ifile][5][4][0],DATA_LBAND[ifile][5][3][0],\
                    DATA_LBAND[ifile][1], fontsize=8)


    for k in range(kinit,len(XL)):
    
        plt.plot(XL[k],YL[k],linewidth=0.3,color=colorvec[k])
        for i in xrange(0,len(XL[k])):
            if H14BL[k][i] >= 0.:
                markk="o"
            else:
                markk="^"
            plt.scatter([XL[k][i]],[YL[k][i]],marker=markk,\
                s=1e4*np.abs(H14BL[k][i])/(lamb2_BL-lamb1_BL)/1e4,\
                color=colorvec[k],facecolors="None")
        pass


    #plt.title(figtitle[k])
    plt.xscale('linear')
    plt.yscale('linear')
    plt.xlabel("$\\alpha_L$")
    plt.ylabel("$M_{B_L}\,[\mathrm{mag}]$")
    plt.xlim([-4.5,-0.5])
    plt.ylim([-0.5,-7.0])

    #plt.xlim([np.nanmin(alphaL)-0.1*(np.nanmax(alphaL)-np.nanmin(alphaL)),\
    #    np.nanmax(alphaL)+0.1*(np.nanmax(alphaL)-np.nanmin(alphaL))])
    #plt.ylim([np.nanmax(BL_Bvega)+0.1*(np.nanmax(BL_Bvega)-np.nanmin(BL_Bvega)),\
    #    np.nanmin(BL_Bvega)-0.1*(np.nanmax(BL_Bvega)-np.nanmin(BL_Bvega))])
        
    plt.tight_layout()
    #plt.show()
    plt.savefig(figures+"CMD_"+figname_now)











#############################
### Plotting magnitude diagrams for the work with Alejandro and K. Vieira
if 1==2:
    
    i_n = npar.index("3.5")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("14.60")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")
    
    colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    



    xmax = np.nanmax(UBVRI[:,:,:,:,:,1]-UBVRI[:,:,:,:,:,2])
    xmin = np.nanmin(UBVRI[:,:,:,:,:,1]-UBVRI[:,:,:,:,:,2])
    ymax = np.nanmax(UBVRI[:,:,:,:,:,2])
    ymin = np.nanmin(UBVRI[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = UBVRI[i_n,i_sig,i_M,i_ob,:,1]-UBVRI[i_n,i_sig,i_M,i_ob,:,2]
        #y = UBVRI[i_n,i_sig,i_M,i_ob,:,2]
        x = UBVRI[:,:,:,:,:,1]-UBVRI[:,:,:,:,:,2]
        y = UBVRI[:,:,:,:,:,2]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("B-V")
    plt.ylabel("V")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    
    xmax = np.nanmax(UBVRI[:,:,:,:,:,2]-UBVRI[:,:,:,:,:,4])
    xmin = np.nanmin(UBVRI[:,:,:,:,:,2]-UBVRI[:,:,:,:,:,4])
    ymax = np.nanmax(UBVRI[:,:,:,:,:,2])
    ymin = np.nanmin(UBVRI[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = UBVRI[i_n,i_sig,i_M,i_ob,:,2]-UBVRI[i_n,i_sig,i_M,i_ob,:,4]
        #y = UBVRI[i_n,i_sig,i_M,i_ob,:,2]
        x = UBVRI[:,:,:,:,:,2]-UBVRI[:,:,:,:,:,4]
        y = UBVRI[:,:,:,:,:,2]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("V-I")
    plt.ylabel("V")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()


    xmax = np.nanmax(JHK[:,:,:,:,:,0]-JHK[:,:,:,:,:,1])
    xmin = np.nanmin(JHK[:,:,:,:,:,0]-JHK[:,:,:,:,:,1])
    ymax = np.nanmax(JHK[:,:,:,:,:,1]-JHK[:,:,:,:,:,2])
    ymin = np.nanmin(JHK[:,:,:,:,:,1]-JHK[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-JHK[i_n,i_sig,i_M,i_ob,:,1]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,1]-JHK[i_n,i_sig,i_M,i_ob,:,2]
        x = JHK[:,:,:,:,:,0]-JHK[:,:,:,:,:,1]
        y = JHK[:,:,:,:,:,1]-JHK[:,:,:,:,:,2]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-H")
    plt.ylabel("H-K")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymin-0.1*(ymax-ymin),\
                ymax+0.1*(ymax-ymin)])
    plt.show()



    xmax0 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,0])
    xmax1 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,1])
    xmax2 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,2])
    xmax3 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,3])
    xmin0 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,0])
    xmin1 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,1])
    xmin2 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,2])
    xmin3 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,3])
    xmax = np.nanmax([xmax0,xmax1,xmax2,xmax3])
    xmin = np.nanmax([xmin0,xmin1,xmin2,xmin3])
    ymax = np.nanmax(JHK[:,:,:,:,:,0])
    ymin = np.nanmin(JHK[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,0]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,0]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[1]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,1]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,1]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[2]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,2]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,2]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[3]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,3]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,3]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[4]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()


    


    import sys; sys.exit()


if 1==2:
    
    def lnprobPriorStar(theta, uvlims, Z):
        """ Returns the prior probability function. """
        n=theta[0]
        Sig0=theta[1]
        M=theta[2]
        W=theta[3]
        cosi=theta[4]
        
        p = priorn(n,uvlims[0][0],uvlims[0][1])*\
            priorSig0(Sig0,uvlims[1][0],uvlims[1][1])*\
            priorM(M,uvlims[2][0],uvlims[2][1],Z)*\
            priorW(W,uvlims[3][0],uvlims[3][1])*\
            priorcosi(cosi,uvlims[4][0],uvlims[4][1])
        if p == 0.:
            return -np.inf
        else:
            return np.log(p)

    def priorn(n,nmin,nmax):
        """ Returns the *a priori* probability of a star with main sequence
        age Tau be a Be star. """
        #interval check
        if n < nmin or n > nmax:
            return 0.
    
        return 1.
    
    def priorSig0(Sig0,Sig0min,Sig0max):
        """ Returns the *a priori* probability of a star with main sequence
        age Tau be a Be star. """
        #interval check
        if Sig0 < Sig0min or Sig0 > Sig0max:
            return 0.

        return 1./Sig0


    def priorM(M,Mmin,Mmax, Z=0.007):
        """ Returns the *a priori* probability of a star with mass M be a Be star.
    
        Masses always in Solar units. """
        #interval check
        if M < Mmin or M > Mmax:
            return 0.

        p = M**(-2.3)*fM(M, Z)

        return p

    def fM(M, Z):
        """ Function of the Be phenomenon as function of mass """
        if Z >= 0.045:
            a = .0017; b = 2.342
        else:
            a = .0107; b = 1.871
        #
        if M >= (1./a)**(1./b):
            p = 1.
        else:
            p = a*M**b
        return p
 

    def priorW(W,Wmin,Wmax):
        """ Returns the *a priori* probability of a star with rotation rate W be a
        Be star. """
        #interval check
        if W < Wmin or W > Wmax:
            return 0.

        Wmean = .81
        sigW = .12

        p = np.exp(-(W-Wmean)**2./(2.*sigW**2.))

        return p


    def priorcosi(cosi,cosimin,cosimax):
        """ Returns the *a priori* probability of a star at inclination angle i 
        be a Be star. """
        #interval check
        if cosi < cosimin or cosi > cosimax:
            return 0.

        return 1.


    nwalkers = 250  ### 250
    nsampling = 100 ### 100
    nchain = nsampling + 2000    ### 2000
    ndim = 5

    Z = 0.002
    uvlims= [   [3.0,4.5],\
                [0.02,4.0],\
                [3.2,14.6],\
                [0.,1.],\
                [0.,1.]\
            ]


    ### Choose an initial set of positions for the walkers.
    ### (It is a list of ndim-dimensional lists.)
    p0 = [  [np.random.uniform(uvlims[0][0],uvlims[0][1]),\
            np.random.uniform(uvlims[1][0],uvlims[1][1]),\
            np.random.uniform(uvlims[2][0],uvlims[2][1]),\
            np.random.uniform(uvlims[3][0],uvlims[3][1]),\
            np.random.uniform(uvlims[4][0],uvlims[4][1])] 
                for i in xrange(nwalkers)]



    ### Initialize the sampler with the chosen specs.
    sampler = emcee.EnsembleSampler(nwalkers, ndim, lnprobPriorStar, \
        args=[uvlims,Z], a=2, threads=1)


    print("SAMPLING...")
    pos, prob, state = sampler.run_mcmc(p0, nchain)
    print("SAMPLING DONE.")

    ### Uncheck this to see the evolution of the probabilities 
    ### for 'measuring x alone'
    if 1==2:
        lnprobability=[]
        lnprobability.append(sampler.lnprobability)

        poslnprob=np.arange(1,len(lnprobability[0][0])+1)
        fig=plt.figure(figsize=(6,6))
        ax=plt.subplot(1,1,1)
        
        for i in xrange(0,len(lnprobability[0])):
            plt.plot(poslnprob,[np.arcsinh(lnprobability[0][i][j]) \
                for j in range(0,len(lnprobability[0][0]))], \
                color='black', linewidth=0.05, linestyle='-')
        plt.ylabel("$\\arcsinh(\\ln(\\mathrm{prob}))$")
        plt.xlabel("position in the chain")
        plt.show()


    walkerss = []
    for ii in range(0,nwalkers*nsampling):
        walkerss.append(sampler.flatchain[-1-ii])

    
    



    nparf = np.array([float(elem) for elem in npar])
    sigparf = np.array([float(elem) for elem in sigpar])
    Mparf = np.array([float(elem) for elem in Mpar])
    Wparf = np.array([np.sqrt(2.*float(elem)-2.) for elem in obpar])
    cosiparf = np.array([abs(float(elem)) for elem in cosipar])

    axis = [nparf,sigparf,Mparf,Wparf,cosiparf]


    print("INTERPOLATING...")
    ### Atributing values to every point in the grid.
    UBVRI1values=[]
    UBVRI2values=[]
    UBVRI3values=[]
    UBVRI4values=[]
    UBVRI5values=[]
    HALPHA_SOARvalues=[]
    JHK1values=[]
    JHK2values=[]
    JHK3values=[]
    IRAC1values=[]
    IRAC2values=[]
    IRAC3values=[]
    IRAC4values=[]
    for i in xrange(0,len(nparf)):
        for j in xrange(0,len(sigparf)):
            for k in xrange(0,len(Mparf)):
                for l in xrange(0,len(Wparf)):
                    for m in xrange(0,len(cosiparf)):
                        UBVRI1values.append(UBVRI[i,j,k,l,m,0])
                        UBVRI2values.append(UBVRI[i,j,k,l,m,1])
                        UBVRI3values.append(UBVRI[i,j,k,l,m,2])
                        UBVRI4values.append(UBVRI[i,j,k,l,m,3])
                        UBVRI5values.append(UBVRI[i,j,k,l,m,4])
                        HALPHA_SOARvalues.append(HALPHA_SOAR[i,j,k,l,m])
                        JHK1values.append(JHK[i,j,k,l,m,0])
                        JHK2values.append(JHK[i,j,k,l,m,1])
                        JHK3values.append(JHK[i,j,k,l,m,2])
                        IRAC1values.append(IRAC[i,j,k,l,m,0])
                        IRAC2values.append(IRAC[i,j,k,l,m,1])
                        IRAC3values.append(IRAC[i,j,k,l,m,2])
                        IRAC4values.append(IRAC[i,j,k,l,m,3])


    UBVRI1walkers = []
    UBVRI2walkers = []
    UBVRI3walkers = []
    UBVRI4walkers = []
    UBVRI5walkers = []
    HALPHA_SOARwalkers = []
    JHK1walkers = []
    JHK2walkers = []
    JHK3walkers = []
    IRAC1walkers = []
    IRAC2walkers = []
    IRAC3walkers = []
    IRAC4walkers = []
    print("INTERPOLATIONS FOR U FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI1walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI1values))
    print("INTERPOLATIONS FOR B FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI2walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI2values))
    print("INTERPOLATIONS FOR V FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI3walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI3values))
    print("INTERPOLATIONS FOR R FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI4walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI4values))
    print("INTERPOLATIONS FOR I FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI5walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI5values))
    print("INTERPOLATIONS FOR SOAR'S HALPHA FILTER...")
    for ii in range(0,len(walkerss)):
        HALPHA_SOARwalkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,HALPHA_SOARvalues))
    print("INTERPOLATIONS FOR J FILTER...")
    for ii in range(0,len(walkerss)):
        JHK1walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,JHK1values))
    print("INTERPOLATIONS FOR H FILTER...")
    for ii in range(0,len(walkerss)):
        JHK2walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,JHK2values))
    print("INTERPOLATIONS FOR K FILTER...")
    for ii in range(0,len(walkerss)):
        JHK3walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,JHK3values))
    print("INTERPOLATIONS FOR IRAC 1 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC1walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC1values))
    print("INTERPOLATIONS FOR IRAC 2 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC2walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC2values))
    print("INTERPOLATIONS FOR IRAC 3 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC3walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC3values))
    print("INTERPOLATIONS FOR IRAC 4 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC4walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC4values))
        
    print("INTERPOLATIONS DONE.")

    fileext = "KV_walkers.txt"
    f0 = open(fileext,"w")
    
    for ii in range(0,len(walkerss)):
        f0.write(   str(walkerss[ii][0])+str(" ")+\
                    str(walkerss[ii][1])+str(" ")+\
                    str(walkerss[ii][2])+str(" ")+\
                    str(walkerss[ii][3])+str(" ")+\
                    str(walkerss[ii][4])+str(" ")+\

                    str(UBVRI1walkers[ii])+str(" ")+\
                    str(UBVRI2walkers[ii])+str(" ")+\
                    str(UBVRI3walkers[ii])+str(" ")+\
                    str(UBVRI4walkers[ii])+str(" ")+\
                    str(UBVRI5walkers[ii])+str(" ")+\
                    str(JHK1walkers[ii])+str(" ")+\
                    str(JHK2walkers[ii])+str(" ")+\
                    str(JHK3walkers[ii])+str(" ")+\
                    str(IRAC1walkers[ii])+str(" ")+\
                    str(IRAC2walkers[ii])+str(" ")+\
                    str(IRAC3walkers[ii])+str(" ")+\
                    str(IRAC4walkers[ii])+str(" ")+\
                    "\n"
        )
    
    f0.close()



##########################################################
##########################################################
### Now, comes the part 2 of the analysis: MCMC fitting for comparison 
### of models and observations.


def fBe(M,A):
    
    ell = 1.4*M**3.5
    log10ell = np.log10(1.4)+3.5*np.log10(M)
    
    
    
    A0 = -14.09101
    A1 = 8.71656
    A2 = -1.95159
    A3 = 0.11596
    A4 = 0.
    A5 = 0.
    A6 = 0.
    
    logf = \
    A0+\
    A1*log10ell+\
    A2*log10ell**2.+\
    A3*log10ell**3.+\
    A4*log10ell**4.+\
    A5*log10ell**5.+\
    A6*log10ell**6.
    
    return A*np.exp(logf)


def find_area():

    Ar = 1.
    x = np.array([1.+0.01*float(i) for i in range(0,3500+1)])
    y = np.array([fBe(elem,Ar) for elem in x])

    ymin = 0.
    ymax = np.nanmax(y)
    xmin = np.nanmin(x)
    xmax = np.nanmax(x)

    icount = 0.
    incount = 0.
    for i in range(0,1000000):
        icount += 1.
        xr = np.random.uniform(xmin,xmax,None)
        yr = np.random.uniform(ymin,ymax,None)
        if yr <= fBe(xr,Ar):
            incount += 1.

    print(incount/icount*(xmax-xmin)*(ymax-ymin))

    return


if 1==2:

    A = 1.
    x = np.array([1.+0.01*float(i) for i in range(0,3500+1)])
    y = np.array([fBe(elem,A) for elem in x])


    plt.figure(figsize=(5.5,2.5))
    plt.plot(x,y)
    plt.xlabel("$M/M_\odot$")
    plt.ylabel("$f_\mathrm{Be}$")
    plt.xscale("log")
    #plt.yscale("log")
    plt.tight_layout()
    plt.show()











